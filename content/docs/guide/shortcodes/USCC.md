---
title: Unitary Selective Coupled Cluster
linkTitle: 7- USCC
---




<!--more-->

The Unitary Coupled-Cluster with Singles and Doubles (UCCSD) method parameterizes coupled-cluster variational parameters for each fermionic excitation from a reference state, whether single or double excitations. This ansatz has been successfully applied to compute accurate electronic energies for small molecules. However, for large molecules, this approach can introduce many redundant, unimportant excitations, resulting in a large number of parameters to optimize and excessively long circuits


 The UsCC method systematically reduces the energy error with an increasing ansatz size for a set of test molecules. A significant advantage of the UsCC method is that expanding the ansatz does not necessitate additional measurements on a quantum computer. The implementation of the UsCC method begins with the reference Hartree–Fock state. One- and two-body excitations (from occupied to unoccupied orbitals) with corresponding Hamiltonian matrix elements above a given threshold \(\epsilon\) are included in the ansatz. A Variational Quantum Eigensolver (VQE) is then performed on this ansatz until convergence, completing the first iteration. In subsequent iterations, the threshold is updated such that \(\epsilon_i = \frac{\epsilon_{i-1}}{2}\). New, higher-order excitations are generated by applying one- and two-body excitations to those already included in the ansatz. The metric to compare to the threshold for inclusion of these excitations is obtained by multiplying the parameters obtained after optimization at the previous step with the Hamiltonian matrix element corresponding to the single or double excitation added. As in previous iterations, coefficients that are above the threshold are included in the ansatz and then optimized through VQE. The optimization continues until a convergence criterion is met or sufficient excitations have been included.


The ansatz generation starts with the reference Hartree–Fock state, with no initial excitation amplitudes available. First, all possible single- and double-electronic excitations are generated. These excitations are expressed in spin-block notation: the occupied orbitals, from which excitations are performed, are labeled $i$, $j$, $k$, and $l$, while the virtual orbitals, to which electrons are excited, are labeled $p$, $q$, $r$, and $s$. For instance, single and double excitations are denoted as $[i, p]$ and $[i, j, p, q]$, respectively.



### UsCCSDTQ-VQE Algorithm


1.   Generate single and double excitations for a given molecule.

For all single (S) and double (D) excitations \([i, p]\) and \([i, j, p, q]\) in UCCSD:

- **If** \(h_1[i, p]\) and \(h_2[i, j, p, q]\) are larger than \(\epsilon_1\) **then**:
  - Add to ansatz.
  - **end if**

**end for**

**Repeat.**

2. Run VQE with the current ansatz to compute energy, update amplitudes for each excitation present in ansatz.


3.  For each single $[i, p]$ or double $[i, j, p, q]$ excitation present in ansatz using $t_1$ and $t_2$ values from the previous iteration and additional excitations $[k, r]$ or $[k, l, r, s]$, generate triple and quadruple excitations with the following coefficients:

    -  $t_1[i, p] \cdot h_2[j, k, q, r]$
    - $h_1[i, p] \cdot t_2[j, k, q, r]$
    - $t_2[i, j, p, q] \cdot h_1[k, r]$
    - $h_2[i, j, p, q] \cdot t_1[k, r]$
    - $t_2[i, j, p, q] \cdot h_2[k, l, r, s]$

4.  For each excitation, if the absolute value of the largest coefficient computed in step 3 is larger than $\epsilon_n$ on iteration $n$, add this excitation to ansatz.

### Code Source Implementation

{{% steps %}}

### Step 1
**Import necessary library and define the fucntions**

```python {class="my-class" id="my-codeblock" lineNos=inline tabWidth=2}
from openvqe.common_files.qubit_pool import QubitPool
from openvqe.common_files.molecule_factory import MoleculeFactory
from openvqe.ucc_family.get_energy_ucc import EnergyUCC
from qat.fermion.transforms import (get_jw_code, recode_integer)
from qat.fermion.chemistry.pyscf_tools import perform_pyscf_computation
from qat.fermion.chemistry.pyscf_tools import perform_pyscf_computation
from qat.fermion.chemistry import MolecularHamiltonian, MoleculeInfo
from qat.fermion.chemistry.ucc import guess_init_params, get_hf_ket, get_cluster_ops
from qat.fermion.transforms import transform_to_jw_basis  # , transform_to_bk_basis, transform_to_parity_basis
from qat.fermion.transforms import recode_integer, get_jw_code  # , get_bk_code, get_parity_code
from qat.lang.AQASM import Program, X
from qat.fermion.trotterisation import make_trotterisation_routine
from qat.fermion import ElectronicStructureHamiltonian
import scipy.optimize
from qat.fermion.chemistry.ucc_deprecated import build_ucc_ansatz
from qat.lang.AQASM import Program
from qat.qpus import get_default_qpu
from openvqe.common_files.circuit import count
import numpy as np

class EnergyUCC:
    def ucc_action(self, theta_current, hamiltonian_sp, cluster_ops_sp, hf_init_sp, theta_thresh=1e-7):
        """
        It maps the exponential of cluster operators ("cluster_ops_sp") associated by their parameters ("theta_current")
        using the CNOTS-staircase method, which is done by "build_ucc_ansatz" which creates the circuit on the top of
        the HF-state ("hf_init_sp"). Then, this function also calculates the expected value of the hamiltonian ("hamiltonian_sp").

        Parameters
        ----------
        theta_current: List<float>
            the Parameters of the cluster operators
        
        hamiltonian_sp: Hamiltonian
                Hamiltonian in the spin representation
            
        cluster_ops_sp: list[Hamiltonian]
            list of spin cluster operators
        
        hf_init_sp: int
            the integer corresponds to the hf_init (The Hartree-Fock state in integer representation) obtained by using
            "qat.fermion.transforms.record_integer".
        
        Returns
        --------
            res.value: float
                the resulted energy

        """
        qpu = 0
        prog = 0
        reg = 0
        qpu = get_default_qpu()
        prog = Program()
        reg = prog.qalloc(hamiltonian_sp.nbqbits)
        qrout = 0
        for n_term, (term, theta_term) in enumerate(zip(cluster_ops_sp, theta_current)):
            init = hf_init_sp if n_term == 0 else 0
            qprog = build_ucc_ansatz([term], init, n_steps=1)
            if abs(theta_term) > theta_thresh:
                prog.apply(qprog([theta_term]), reg)
        circ = prog.to_circ()

        return circ
    
    def get_optimization_func(self, circ, qpu, hamiltonian_sp, method, nqbits, psi0, energy_list, fid_list):
    # below, I show an example of minimization of the energy where I store the energy and fidelity for each parameter
    # I use a gradient-free procedure.
        def my_func(x):
            """returns energy given parameter x, and stores it + the fidelity of state"""
            circ1 = circ.bind_variables(
                {k: v for k, v in zip(sorted(circ.get_variables()), x)}
            )
            res0 = qpu.submit(circ1.to_job(observable=hamiltonian_sp))
            energy = res0.value
            energy_list[method].append(energy)

            # additional computation to compute fidelity (just for my own information)
            res = qpu.submit(circ1.to_job())
            psi = np.zeros((2**nqbits,), complex)
            for sample in res:
                psi[sample.state.int] = sample.amplitude
            fid = abs(psi.conj().dot(psi0)) ** 2
            fid_list[method].append(fid)

            return energy

        return my_func


    def get_grad_func(self, circ, qpu, hamiltonian_sp):
        # here I show a gradient-based minimization strategy
        def my_grad(x):
            grads = circ.to_job(observable=hamiltonian_sp).gradient()
            grad_list = []
            for var_name in sorted(circ.get_variables()):
                list_jobs = grads[var_name]
                # list_jobs contains jobs to compute E(theta+pi/2) and E(theta-pi/2)
                # the gradient w.r.t theta is then 0.5 (E(theta+pi/2) - E(theta-pi/2))
                grad = 0.0
                for ind in range(len(list_jobs)):
                    circ1 = list_jobs[ind].circuit.bind_variables(
                        {k: v for k, v in zip(circ.get_variables(), x)}
                    )
                    job = circ1.to_job(observable=list_jobs[ind].observable)
                    res = qpu.submit(job)
                    grad += 0.5 * res.value
                grad_list.append(grad)
            return grad_list


    def prepare_state_ansatz(
        self, hamiltonian_sp, cluster_ops_sp, hf_init_sp, parameters
    ):
        """
        It constructs the trial wave function (ansatz) 

        Parameters
        ----------
        hamiltonian_sp: Hamiltonian
                Hamiltonian in the spin representation
            
        cluster_ops_sp: list[Hamiltonian]
            list of spin cluster operators
        
        hf_init_sp: int
            the integer corresponds to the hf_init (The Hartree-Fock state in integer representation) obtained by using
            "qat.fermion.transforms.record_integer".
        
        parameters: List<float>
            the Parameters for the trial wave function to be constructed
        


        Returns
        --------
            curr_state: qat.core.Circuit
                the circuit that represent the trial wave function
        
        """
        qpu = get_default_qpu()
        prog = Program()
        reg = prog.qalloc(hamiltonian_sp.nbqbits)
        for n_term, (term, theta_term) in enumerate(zip(cluster_ops_sp, parameters)):
            init = hf_init_sp if n_term == 0 else 0
            qprog = build_ucc_ansatz([term], init, n_steps=1)
            prog.apply(qprog([theta_term]), reg)
        circ = prog.to_circ()
        curr_state = circ
        return curr_state

    def get_energies(
        self,
        hamiltonian_sp,
        cluster_ops_sp,
        hf_init_sp,
        theta_current,
        fci,
        method="BFGS"
    ):
        """
        It calls internally the functions "ucc_action" and "prepare_state_ansatz", and uses scipy.optimize to
        return the properties of the ucc energy and wave function.

        Parameters
        ----------
        hamiltonian_sp: Hamiltonian
                Hamiltonian in the spin representation
            
        cluster_ops_sp: list[Hamiltonian]
            list of spin cluster operators

        hf_init_sp: int
            the integer corresponds to the hf_init (The Hartree-Fock state in integer representation) obtained by using
            "qat.fermion.transforms.record_integer".
        
        theta_current: List<float>
            the Parameters of the cluster operators of "cluster_ops_sp"
        
        
        theta_current2: List<float>
            the Parameters of the cluster operators of "pool_generator"
        

        theta_current2: List<float>
            the Parameters of the cluster operators of "pool_generator"
        
        fci: float
            the full configuration interaction energy (for any basis set)
    
        
        Returns
        --------
            iterations: Dict
                the minimum energy and the optimized parameters
            
            result: Dict
                the number of CNOT gates, the number of operators/parameters, and the substraction of the optimized energy from fci.
        
        """

        iterations = {
            "minimum_energy_result_guess": [],
            "theta_optimized_result": [],
        }
        result = {}
        tolerance = 10 ** (-4)
        print("tolerance= ", tolerance)
        print("method= ", method)

        theta_optimized_result = []

        

        opt_result = scipy.optimize.minimize(
            lambda theta: self.ucc_action(
                theta, hamiltonian_sp, cluster_ops_sp, hf_init_sp
            ),
            x0=theta_current,
            method=method,
            tol=tolerance,
            options={"maxiter": 50000, "disp": True},
        )

        xlist = opt_result.x

        for si in range(len(theta_current)):
            theta_optimized_result.append(xlist[si])

        curr_state_result = self.prepare_state_ansatz(
            hamiltonian_sp, cluster_ops_sp, hf_init_sp, theta_optimized_result
        )

        gates = curr_state_result.ops
        cnot = count("CNOT", gates)
        iterations["minimum_energy_result_guess"].append(opt_result.fun)
        iterations["theta_optimized_result"].append(theta_optimized_result)
        result["CNOT"] = cnot
        result["len_op"] = len(theta_optimized_result)
        result["energies_substracted_from_FCI"] = abs(opt_result.fun - fci)
        return iterations, result

```

### Step 2
**Callout the function and excecute the program**
```python {class="my-class" id="my-codeblock" lineNos=inline tabWidth=2}
from openvqe.common_files.molecule_factory import MoleculeFactory
#from openvqe.ucc_family.get_energy_ucc import EnergyUCC
from openvqe.common_files.generator_excitations import _apply_transforms
from qat.fermion.transforms import get_jw_code, recode_integer
from qat.core import Term
from qat.fermion import FermionHamiltonian


def get_h(hamiltonian, exc):
    hamiltonian_string = str(hamiltonian)
    lines = hamiltonian_string.strip().split("\n")
    if len(exc) == 2:
        id_str = f"(Cc|[{exc[0]}, {exc[1]}])"
    else:
        id_str = f"(CCcc|[{exc[0]}, {exc[1]}, {exc[2]}, {exc[3]}])"

    lines = [line for line in lines if id_str in line]
    if len(lines) == 0:
        print("zero h:", exc)
        return complex(0.0)
    assert len(lines) == 1

    line = lines[0]
    start_ind = line.find("(") + 1
    end_ind = line.find(")")
    value = line[start_ind:end_ind]
    return complex(value)


def init(molecule_symbol):
    (
        hamiltonian,
        hamiltonian_sp,
        _,
        active_noons,
        _,
        info,
    ) = MoleculeFactory().generate_hamiltonian(
        molecule_symbol, active=False, transform="JW"
    )

    (
        _,
        cluster_ops,
        _,
        theta_MP2,
        hf_init,
    ) = MoleculeFactory().generate_cluster_ops(
        molecule_symbol, type_of_generator="UCCSD", transform="JW", active=False
    )

    hf_init_sp = recode_integer(hf_init, get_jw_code(hamiltonian_sp.nbqbits))
    fci = info["FCI"]
    print("FCI", fci)
    nqbits = len(active_noons)

    excitations = [tuple(op.terms[0].qbits) for op in cluster_ops]
    current_coeffs = {}

    # TODO:
    # theta_MP2 = [x if x != 0 else 0.01 for x in theta_MP2]
    theta_MP2 = [0.01 for x in theta_MP2]
    for i, exc in enumerate(excitations):
        current_coeffs[exc] = {"h": get_h(hamiltonian, exc)}

    return hamiltonian_sp, hf_init_sp, fci, current_coeffs, nqbits


def build_cluster_ops(exc_list, nqbits: int):
    """Adapted from myqlm"""
    t_opti = []

    for op_index in exc_list:
        current_excitation_op = []

        op_description, indices, indices_conj = None, None, None
        if len(op_index) == 2:
            op_description = "Cc"
            indices, indices_conj = list(op_index), [op_index[1], op_index[0]]

        elif len(op_index) == 4:
            op_description = "CCcc"
            indices, indices_conj = list(op_index), [
                op_index[2],
                op_index[3],
                op_index[0],
                op_index[1],
            ]
        elif len(op_index) == 6:
            op_description = "CCCccc"
            indices, indices_conj = list(op_index), [
                op_index[3],
                op_index[4],
                op_index[5],
                op_index[0],
                op_index[1],
                op_index[2],
            ]

        elif len(op_index) == 8:
            op_description = "CCCCcccc"
            indices, indices_conj = list(op_index), [
                op_index[4],
                op_index[5],
                op_index[6],
                op_index[7],
                op_index[0],
                op_index[1],
                op_index[2],
                op_index[3],
            ]

        current_excitation_op.append(Term(1j, op_description, indices))
        current_excitation_op.append(Term(-1j, op_description, indices_conj))
        t_opti.append(FermionHamiltonian(nqbits=nqbits, terms=current_excitation_op))

    return t_opti


def update_ansatz(current_excitations, current_coeffs, thresh, nqbits):
    all_excitations = list(current_coeffs.keys())

    for optimized_exc in current_excitations:
        for exc in all_excitations:
            exc_len = len(exc)
            opt_exc_len = len(optimized_exc)

            # single-single
            if exc_len == 2 and opt_exc_len == 2:
                new_exc = sorted([exc[0], optimized_exc[0]]) + sorted(
                    [exc[1], optimized_exc[1]]
                )
            elif exc_len == 2 and opt_exc_len == 4:
                new_exc = sorted([exc[0], optimized_exc[0], optimized_exc[1]]) + sorted(
                    [exc[1], optimized_exc[2], optimized_exc[3]]
                )
            elif exc_len == 4 and opt_exc_len == 2:
                new_exc = sorted([exc[0], exc[1], optimized_exc[0]]) + sorted(
                    [exc[2], exc[3], optimized_exc[1]]
                )
            elif exc_len == 4 and opt_exc_len == 4:
                new_exc = sorted(
                    [exc[0], exc[1], optimized_exc[0], optimized_exc[1]]
                ) + sorted([exc[2], exc[3], optimized_exc[2], optimized_exc[3]])
            else:
                continue

            if len(set(new_exc)) != len(new_exc):
                continue
            th = 0
            ht = 0
            if "t" in current_coeffs[optimized_exc] and "h" in current_coeffs[exc]:
                # print(
                #     thresh,
                #     f"t{opt_exc_len//2}",
                #     f"h{exc_len//2}",
                #     len(new_exc) // 2,
                #     current_coeffs[optimized_exc]["t"],
                #     current_coeffs[exc]["h"],
                # )
                th = current_coeffs[optimized_exc]["t"] * current_coeffs[exc]["h"]
            if "t" in current_coeffs[exc] and "h" in current_coeffs[optimized_exc]:
                # print(
                #     thresh,
                #     f"h{opt_exc_len//2}",
                #     f"t{exc_len//2}",
                #     len(new_exc) // 2,
                #     current_coeffs[optimized_exc]["h"],
                #     current_coeffs[exc]["t"],
                # )
                ht = current_coeffs[optimized_exc]["h"] * current_coeffs[exc]["t"]

            new_exc = tuple(new_exc)
            if new_exc not in current_coeffs:
                current_coeffs[new_exc] = {}

            current_coeffs[new_exc]["th"] = max(
                current_coeffs[new_exc].get("th", 0), abs(th)
            )
            current_coeffs[new_exc]["ht"] = max(
                current_coeffs[new_exc].get("ht", 0), abs(ht)
            )

    for exc in current_coeffs.keys():
        if exc in current_excitations:
            continue

        coeffs = list(map(abs, current_coeffs[exc].values()))
        max_coeff = max(coeffs)
        if max_coeff > thresh:
            print("ADDED", exc)
            current_excitations.append(exc)

    current_theta = [
        current_coeffs[exc]["t"] if "t" in current_coeffs[exc] else 0.01
        for exc in current_excitations
    ]

    cluster_ops = build_cluster_ops(current_excitations, nqbits)
    _, _, cluster_ops_sp = _apply_transforms(cluster_ops, "JW")

    return current_excitations, current_theta, cluster_ops_sp


def iterate(hamiltonian_sp, ansatz_ops, hf_init_sp, theta_current, fci):
    iterations, result = EnergyUCC().get_energies(
        hamiltonian_sp, ansatz_ops, hf_init_sp, theta_current, fci, "BFGS"
    )
    new_theta = iterations["theta_optimized_result"][0]
    energy = result["energies_substracted_from_FCI"]
    print("ENERGY ERROR", energy)
    
    return new_theta, energy


def energy_stop_condition(energy):
    return False


thresholds = iter(
    [0.04, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002, 1e-4, 1e-5, 1e-6, 1e-7]
)
hamiltonian_sp, hf_init_sp, fci, current_coeffs, nqbits = init("LIH")
current_excitations = []
thresh = next(thresholds)

just_count = 0
while True:
    prev_num_excitations = len(current_excitations)
    current_excitations, current_theta, cluster_ops_sp = update_ansatz(
        current_excitations, current_coeffs, thresh, nqbits
    )
    if len(current_excitations) == prev_num_excitations:
        try:
            thresh = next(thresholds)
        except StopIteration:
            break
        continue
    print("Optimization:", just_count)
    just_count += 1


    
    new_theta, energy = iterate(
        hamiltonian_sp, cluster_ops_sp, hf_init_sp, current_theta, fci
    )
    if energy_stop_condition(energy):
        break

    for i, exc in enumerate(current_excitations):
        current_coeffs[exc]["t"] = new_theta[i]


for exc in current_excitations:
    print(exc)

```



{{% /steps %}}

### Analytical Results

We test UsCCSDTQ-VQE on H$_4$ and LiH molecules using PMRS method (described in the previous section). We emulate 8  qubits in STO-3G basis set. Numerical results are shown in **Figure 1** for H$_4$  and **2** LiH for  as below: 

<p align="center">
  <img src="/uploads/notebook7/spack1.png" alt="Image Description" width="1300"/>
  <br>
  <em><strong>Figure 1:</strong> PMRS application on UsCCSDTQ-VQE algorithm using H<sub>4</sub> molecule (<strong>8 qubits</strong>) at 0.85&Aring;, using BFGS optimizer: (<strong>left figure</strong>) shows the energy obtained from UsCC simulations with respect to the number of selective parameters. (<strong>Right figure</strong>) shows the number of function evaluations per each iteration. Error is the difference between UsCCDTQ energies and FCI. STO-3G basis set is used.</em>
</p>

<p align="center">
  <img src="/uploads/notebook7/spack2.png" alt="Image Description" width="1300"/>
  <br>
  <em><strong>Figure 2:</strong> PMRS application on UsCCSDTQ-VQE algorithm using LiH molecule (<strong>12 qubits</strong>) at 1.45&Aring;, using BFGS optimizer: (<strong>left figure</strong>) shows the energy obtained from UsCC simulations with respect to the number of selective parameters. (<strong>Right figure</strong>) shows the number of function evaluations per each iteration. Error is the difference between UsCCDTQ energies and FCI. STO-3G basis set is used.</em>
</p>


We observe that only three iterations are needed to reach $10^{-9}$ Hartee for  H$_4$ (with overall 19 parameters to optimize, with function evaluations 225 (first iteration), 198 (second iteration) and  180( third iteration)) and 13 iterations are needed for LiH  reach to  1.06 $\times 10^{-5}$ Hartree, with about 45 function evaluations. We observe that PMRS helps reduce the number of function evaluations in both systems, which would exceed 1000 if PMRS were not used. This is demonstrated in the below table

<table>
  <tr>
    <th align="center"><strong>$\bm{r_{\text{Li} - \text{H}}}$</strong></th>
    <th align="center"><strong>Selective Parameters</strong></th>
    <th align="center"><strong>Functions Evaluation</strong></th>
    <th align="center"><strong>Gradient Evaluation</strong></th>
    <th align="center"><strong>Error (Ha)</strong></th>
  </tr>
  <tr>
    <td align="center">$0.5\mathring{\text{A}}$</td>
    <td align="center">54</td>
    <td align="center">10938</td>
    <td align="center">226</td>
    <td align="center">$3.7\times 10^{-13}$</td>
  </tr>
  <tr>
    <td align="center">$1.0\mathring{\text{A}}$</td>
    <td align="center">68</td>
    <td align="center">10795</td>
    <td align="center">247</td>
    <td align="center">$4.4\times 10^{-13}$</td>
  </tr>
  <tr>
    <td align="center">$1.5\mathring{\text{A}}$</td>
    <td align="center">72</td>
    <td align="center">10640</td>
    <td align="center">242</td>
    <td align="center">$7.84\times 10^{-13}$</td>
  </tr>
  <tr>
    <td align="center">$2.0\mathring{\text{A}}$</td>
    <td align="center">68</td>
    <td align="center">11406</td>
    <td align="center">263</td>
    <td align="center">$1.96\times 10^{-12}$</td>
  </tr>
</table>

<p align="center"><em>Table 1: Test UsCCSDTQ-VQE on LiH <strong>12 qubits</strong>. BFGS optimizer, tolerance $10^{-6}$ (Hartree), STO-3G basis set is used. (Molecule LiH at $r_{\text{Li} -\text{H}} = \left[0.5 - 2.0 \right] \mathring{\text{A}}$)</em></p>


### **References**

<a href="https://arxiv.org/pdf/2109.12652" style="color:#1E90FF;">
Fedorov, Dmitry A., et al. "Unitary selective coupled-cluster method." Quantum 6 (2022): 703.
</a>

<br>

<a href="https://arxiv.org/pdf/2206.08798" style="color:#1E90FF;">
Haidar, Mohammad, et al. "Open source variational quantum eigensolver extension of the quantum learning machine for quantum chemistry." Wiley Interdisciplinary Reviews: Computational Molecular Science 13.5 (2023): e1664.
</a>






### **About the author**



<div align="center">
  <img src="/uploads/notebook7/huybinh.png" alt="Author's Photo" width="150" style="border-radius: 50%; border: 2px solid #1E90FF;">
  <br>
  <strong>Huy Binh TRAN</strong>
  <br>
  <em>Master 2 Quantum Devices at Institute Paris Polytechnic, France</em>
  <br>
  <a href="https://www.linkedin.com/in/huybinhtran/" style="color:#1E90FF;">LinkedIn</a>
</div>


{{< math >}}
{{< /math >}} 













